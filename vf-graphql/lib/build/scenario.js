
// Generated by scripts/build.js - edit the *.gql file instead!

module.exports = `
##
#
# Scenario module
#
# Facilitates grouping of processes together into logical collections of higher level processes.
#
# @depends  agent.gql
# @depends  measurement.gql
# @package  vf-graphql
# @since    2019-02-11
#
##

"""
An estimated or analytical logical collection of higher level processes used for budgeting, analysis, plan refinement, etc.
"""
type Scenario {
  id: ID!
  revisionId: ID!

  "An informal or formal textual identifier for a scenario. Does not imply uniqueness."
  name: String!

  "The beginning date/time of the scenario, often the beginning of an accounting period."
  hasBeginning: DateTime

  "The ending date/time of the scenario, often the end of an accounting period."
  hasEnd: DateTime

  "The scenario definition for this scenario, for example yearly budget."
  definedAs: ScenarioDefinition

  "This scenario refines another scenario, often as time moves closer or for more detail."
  refinementOf: Scenario

  "A textual description or comment."
  note: String

  # inverse relationships and queries

  refinements: [Scenario!]
}

"""
The type definition of one or more scenarios, such as Yearly Budget.
"""
type ScenarioDefinition {
  id: ID!
  revisionId: ID!

  "An informal or formal textual identifier for a scenario definition. Does not imply uniqueness."
  name: String!

  "The duration of the scenario, often an accounting period."
  hasDuration: Duration

  "A textual description or comment."
  note: String

  # inverse relationships and queries

  scenarios(first: Int, after: String, last: Int, before: String): ScenarioConnection
}



input ScenarioCreateParams {
  "An informal or formal textual identifier for a scenario. Does not imply uniqueness."
  name: String!

  "(\`ScenarioDefinition\`) The scenario definition for this scenario, for example yearly budget."
  definedAs: ID

  "The beginning date/time of the scenario, often the beginning of an accounting period."
  hasBeginning: DateTime

  "The ending date/time of the scenario, often the end of an accounting period."
  hasEnd: DateTime

  "(\`Scenario\`) This scenario refines another scenario, often as time moves closer or for more detail."
  refinementOf: ID

  "A textual description or comment."
  note: String
}

input ScenarioUpdateParams {
  revisionId: ID!

  "An informal or formal textual identifier for a scenario. Does not imply uniqueness."
  name: String

  "(\`ScenarioDefinition\`) The scenario definition for this scenario, for example yearly budget."
  definedAs: ID

  "The beginning date/time of the scenario, often the beginning of an accounting period."
  hasBeginning: DateTime

  "The ending date/time of the scenario, often the end of an accounting period."
  hasEnd: DateTime

  "(\`Scenario\`) This scenario refines another scenario, often as time moves closer or for more detail."
  refinementOf: ID

  "A textual description or comment."
  note: String
}

type ScenarioResponse {
  scenario: Scenario!
}



input ScenarioDefinitionCreateParams {
  "An informal or formal textual identifier for a scenario definition. Does not imply uniqueness."
  name: String!

  "The duration of the scenario, often an accounting period."
  hasDuration: IDuration

  "A textual description or comment."
  note: String
}

input ScenarioDefinitionUpdateParams {
  revisionId: ID!

  "An informal or formal textual identifier for a scenario definition. Does not imply uniqueness."
  name: String

  "The duration of the scenario, often an accounting period."
  hasDuration: IDuration

  "A textual description or comment."
  note: String
}

type ScenarioDefinitionResponse {
  scenarioDefinition: ScenarioDefinition!
}


type ScenarioConnection {
  edges: [ScenarioEdge!]!
  pageInfo: PageInfo!
}

type ScenarioEdge {
  node: Scenario!
  cursor: String!
}

type ScenarioDefinitionConnection {
  edges: [ScenarioDefinitionEdge!]!
  pageInfo: PageInfo!
}

type ScenarioDefinitionEdge {
  node: ScenarioDefinition!
  cursor: String!
}

type Query {
  scenario(id: ID!): Scenario
  scenarios(first: Int, after: String, last: Int, before: String): ScenarioConnection!

  scenarioDefinition(id: ID!): ScenarioDefinition
  scenarioDefinitions(first: Int, after: String, last: Int, before: String): ScenarioDefinitionConnection!
}

type Mutation {
  createScenario(plan: ScenarioCreateParams!): ScenarioResponse!
  updateScenario(plan: ScenarioUpdateParams!): ScenarioResponse!
  deleteScenario(revisionId: ID!): Boolean!

  createScenarioDefinition(plan: ScenarioDefinitionCreateParams!): ScenarioDefinitionResponse!
  updateScenarioDefinition(plan: ScenarioDefinitionUpdateParams!): ScenarioDefinitionResponse!
  deleteScenarioDefinition(revisionId: ID!): Boolean!
}

`
