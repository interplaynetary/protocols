##
#
# Data structures needed to manage pagination of data in implementation-agnostic ways.
# Compliant with the Relay connection spec- see https://relay.dev/graphql/connections.htm
#
# The particulars as to *how* a system paginates results, and whether to
# support forwards and/or backwards pagination, are up to each implementation to decide.
# UI applications should thus deal with all possible cases in the presence & absence
# of different fields.
#
# Note also that pagination is a distinct feature from ordering or filtering.
#
# @package  ValueFlows GraphQL
# @since    2021-11-27
#
##

"""Cursors for pagination"""
type PageInfo {
  "Cursor pointing to the first of the results returned, to be used with `before` query parameter if the backend supports reverse pagination."
  startCursor: String
  "Cursor pointing to the last of the results returned, to be used with `after` query parameter if the backend supports forward pagination."
  endCursor: String
  "True if there are more results before `startCursor`. If unable to be determined, implementations should return `true` to allow for requerying."
  hasPreviousPage: Boolean!
  "True if there are more results after `endCursor`. If unable to be determined, implementations should return `true` to allow for requerying."
  hasNextPage: Boolean!
  "The total result count, if it can be determined."
  totalCount: Int
  "The number of items requested per page. Allows the storage backend to indicate this when it is responsible for setting a default and the client does not provide it. Note this may be different to the number of items returned, if there is less than 1 page of results."
  pageLimit: Int
}
