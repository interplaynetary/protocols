import{_ as t,o,c as s,ag as i}from"./chunks/framework.BSbZkL3e.js";const m=JSON.parse('{"title":"full permission (create, update, delete) on a single record type","description":"","frontmatter":{},"headers":[],"relativePath":"at-proto/specs/permissions.md","filePath":"at-proto/specs/permissions.md"}'),a={name:"at-proto/specs/permissions.md"};function n(r,e,p,l,c,u){return o(),s("div",null,[...e[0]||(e[0]=[i('<p>Permissions Control over atproto resources is described and granted using &quot;permissions&quot;. A group of a permissions related to a specific Lexicon namespace (record types and API endpoints) can be bundled together as a &quot;permission set&quot;. Both are used in the context of OAuth to grant client software access to account resources on a PDS. For example, the ability to write records of specific types to the user&#39;s public repository, or make authenticated API requests to remote services. Developers declare the permissions their app requires to function, and end users are shown the permissions when granting access to the app.</p><p>Each resource type has a defined set of parameters that can attenuate the permission. A permission can be represented in a string format (for direct use as an OAuth scope), or as a JSON object (for use in permission sets). Permission sets are published as public lexicon schemas, and are constrained in scope to named resources under the same NSID hierarchy as the NSID of the permission set itself.</p><p>Resource Types Permissions relate to user owned resources on PDS instances:</p><p>repo: Public Repository (records and collections) rpc: Service Authentication (API calls to external services) blob: uploaded media files identity: DID and handle account: hosting status, email address There is an additional &quot;meta&quot; resource, include, which is used to reference a permission set (see Permission Sets section below).</p><p>This section describes these resources in more depth, including all the parameters that can constrain the permission. For each resource, one parameter may be marked as &quot;positional&quot;, which impacts the string representation syntax (described in a later section).</p><p>Resources and permissions are described in the abstract, not tied to specific PDS API endpoints. For example, rpc permissions describe the ability to make remote service API calls using inter-service authentication. This includes both proxied PDS requests (using the Atproto-Proxy HTTP header) and fetching service auth tokens using com.atproto.server.getServiceAuth.</p><p>repo Write access to records in the account&#39;s public repository. Can be limited to specific record types (collections) or actions (eg update vs delete).</p><p>Parameters:</p><p>collection (array of strings, required, positional): NSID of record types. Wildcard (<em>) is allowed in scope string syntax, and grants access to all records. Partial wildcards are not supported (eg, can not use com.example.</em>). Wildcards are not supported in permissions within a permission set. action (array of unique strings, optional): defines the set of record operations allowed. Allowed values are create, update, delete. If not defined, all operations are allowed Examples:</p><h1 id="full-permission-create-update-delete-on-a-single-record-type" tabindex="-1">full permission (create, update, delete) on a single record type <a class="header-anchor" href="#full-permission-create-update-delete-on-a-single-record-type" aria-label="Permalink to &quot;full permission (create, update, delete) on a single record type&quot;">‚Äã</a></h1><p>repo:app.example.profile</p><p>{ &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;repo&quot;, &quot;collection&quot;: [&quot;app.example.profile&quot;] }</p><h1 id="same-as-above-with-actions-being-explicit" tabindex="-1">same as above, with actions being explicit <a class="header-anchor" href="#same-as-above-with-actions-being-explicit" aria-label="Permalink to &quot;same as above, with actions being explicit&quot;">‚Äã</a></h1><p>repo:app.example.profile?action=create&amp;action=update&amp;action=delete</p><p>{ &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;repo&quot;, &quot;collection&quot;: [&quot;app.example.profile&quot;], &quot;action&quot;: [&quot;create&quot;, &quot;update&quot;, &quot;delete&quot;] }</p><h1 id="full-permissions-on-multiple-record-types" tabindex="-1">full permissions on multiple record types <a class="header-anchor" href="#full-permissions-on-multiple-record-types" aria-label="Permalink to &quot;full permissions on multiple record types&quot;">‚Äã</a></h1><p>repo?collection=app.example.profile&amp;collection=app.example.post</p><p>{ &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;repo&quot;, &quot;collection&quot;: [&quot;app.example.profile&quot;, &quot;app.example.post&quot;] }</p><h1 id="full-permissions-on-all-record-types-not-allowed-within-permission-set" tabindex="-1">full permissions on all record types (not allowed within permission set) <a class="header-anchor" href="#full-permissions-on-all-record-types-not-allowed-within-permission-set" aria-label="Permalink to &quot;full permissions on all record types (not allowed within permission set)&quot;">‚Äã</a></h1><p>repo:*</p><h1 id="delete-only-permission-on-all-record-types-not-allowed-within-permission-set" tabindex="-1">delete only permission on all record types (not allowed within permission set) <a class="header-anchor" href="#delete-only-permission-on-all-record-types-not-allowed-within-permission-set" aria-label="Permalink to &quot;delete only permission on all record types (not allowed within permission set)&quot;">‚Äã</a></h1><p>repo:*?action=delete</p><p>rpc The ability to make authenticated API requests to remote services. This includes both requesting service auth tokens (JWTs) using the com.atproto.server.getServiceAuth endpoint on the PDS, and requests proxied via the PDS.</p><p>The permission is parameterized by the remote endpoint (lxm, short for &quot;Lexicon Method&quot;) and the identity of the remote service (the audience, aud). Permissions must be restricted by at least one of these parameter. In other words, the ability to call any API endpoint on any service can not be declared with a single permission.</p><p>When included in a permission set, the audience parameter may be inherited from the overall set.</p><p>Parameters:</p><p>lxm (array of strings, required, positional): NSID of API endpoints. Wildcard (<em>) is allowed in scope string syntax, and gives access to all endpoints. Partial wildcards are not supported (eg, can not use com.example.</em>). Wildcards are not supported in permissions within a permission set. aud (string, semi-required): audience of API requests, as a DID service reference: DID followed by required service type fragment, eg did:web:api.example.com#srvtype). Supports wildcard (*), though as noted above aud and lxm can not both be wildcard. DID references are not allowed in permission set context. Always required in granular string representation; contingent on inheritAud in permission sets. inheritAud (boolean, optional): only used inside permission sets. If true, an aud value will be inherited from the include: invocation, and the aud field is not required on the permission. If inheritAud is true and the permission also defines aud, then the permission is invalid (and should be ignored). If inheritAud is true and no aud is defined on the invoking include:, then the rpc permission is invalid (and should be ignored).</p><p>Examples:</p><h1 id="submit-moderation-reports-to-any-service" tabindex="-1">Submit moderation reports to any service <a class="header-anchor" href="#submit-moderation-reports-to-any-service" aria-label="Permalink to &quot;Submit moderation reports to any service&quot;">‚Äã</a></h1><p>rpc:app.example.moderation.createReport?aud=*</p><p>{ &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;rpc&quot;, &quot;lxm&quot;: [&quot;app.example.moderation.createReport&quot;], &quot;aud&quot;: &quot;*&quot; }</p><h1 id="call-any-rpc-method-on-a-specific-service-not-allowed-within-permission-set" tabindex="-1">Call any RPC method on a specific service (not allowed within permission set) <a class="header-anchor" href="#call-any-rpc-method-on-a-specific-service-not-allowed-within-permission-set" aria-label="Permalink to &quot;Call any RPC method on a specific service (not allowed within permission set)&quot;">‚Äã</a></h1><p>rpc?lxm=*&amp;aud=did:web:api.example.com%23svc_appview</p><p>blob Ability to upload media files (blobs) to PDS.</p><p>Permissions of this type can not be included in permission sets, and must be requested directly by client apps.</p><p>Parameters:</p><p>accept (array of strings, required, positional): MIME types or partial MIME type glob patterns (<em>/</em> or text/* for example). Same syntax as the accept field in the blob lexicon type. Examples:</p><h1 id="upload-any-type-of-blob" tabindex="-1">Upload any type of blob <a class="header-anchor" href="#upload-any-type-of-blob" aria-label="Permalink to &quot;Upload any type of blob&quot;">‚Äã</a></h1><p>blob:<em>/</em></p><h1 id="upload-video-or-html" tabindex="-1">Upload video or html <a class="header-anchor" href="#upload-video-or-html" aria-label="Permalink to &quot;Upload video or html&quot;">‚Äã</a></h1><p>blob?accept=video/*&amp;accept=text/html</p><p>account Control of PDS account hosting details, such as (private) account email.</p><p>Permissions of this type can not be included in permission sets, and must be requested directly by client apps.</p><p>Parameters:</p><p>attr (string, required, positional): a component of account configuration. Wildcard is not supported. action (string, optional): degree of control. Currently supports read or manage. If not specified, default is read. Attributes:</p><p>email: account email address. The read action makes the email and verification status visible. The manage action includes read, and also allows changing the email address. repo: ability to update entire public repository using a CAR file. The manage action allows importing entire CAR files, for example during account migration. The read action does nothing. Examples:</p><h1 id="read-account-email" tabindex="-1">read account email <a class="header-anchor" href="#read-account-email" aria-label="Permalink to &quot;read account email&quot;">‚Äã</a></h1><p>account:email</p><h1 id="import-repo" tabindex="-1">Import repo <a class="header-anchor" href="#import-repo" aria-label="Permalink to &quot;Import repo&quot;">‚Äã</a></h1><p>account:repo?action=manage</p><p>identity Control over network identity, meaning the account DID document and handle. Note that the PDS might not be able to facilitate identity changes if it does not have control over the DID document (for example, when the account uses did:web).</p><p>Permissions of this type can not be included in permission sets, and must be requested directly by client apps.</p><p>Parameters:</p><p>attr (string, required, positional): an aspect or component of account. May be be wildcard (*), indicating full control of DID document and handle. Attributes:</p><p>handle: ability to update handle. This includes the registration of the handle in the DID document, as well as any domain names controlled by the PDS.</p><ul><li>(wildcard): full control over DID document and handle. Examples:</li></ul><h1 id="update-account-handle" tabindex="-1">Update account handle <a class="header-anchor" href="#update-account-handle" aria-label="Permalink to &quot;Update account handle&quot;">‚Äã</a></h1><p>identity:handle</p><p>Scope String Syntax Permissions need to be represented as simple strings when they are requested directly as OAuth scopes. This section describes the syntax for permission scope strings.</p><p>The strings are case-sensitive and use a subset of printable non-whitespace ASCII characters. There is a resource name part, followed by an optional &quot;positional&quot; part separated by a colon (üòÉ, followed by optional parameters starting with a question mark (?). The positional part can contain any characters except for a question mark, including additional colon characters, hash (#), period, etc. and support being percent encoded. Parameters are separated by ampersands (&amp;), have name and value parts separated by equals (=), and support percent-encoding of reserved characters. Array values can be represented by repeated parameters with the same name part.</p><p>For example, the scope string account:repo?action=manage has a resource name account, a &quot;positional&quot; part with the value repo, and a key/value pair action=manage. Knowing that the positional parameter for account is attr, the same permission could be represented as account?action=manage&amp;attr=repo.</p><p>If a parameter is specified in the positional position, it can not also be described in the key/value parameters. Eg, repo:com.example.record?collection=com.example.other is not allowed.</p><p>Examples of syntactically and semantically valid scope strings:</p><p>identity:_ identity:<em>? rpc?lxm=</em>&amp;aud=did:web:api.example.com%23svc_appview blob?accept=video/_&amp;accept=text/html repo:app.example.profile?action=create&amp;action=update&amp;action=delete include:app.example.authFull?aud=did:web:api.example.com%23svc_chat</p><p>Scope strings that match the general syntax, but do not have valid semantics under the current resource definitions:</p><p>resource resource:positional?key=val resource:positional&amp;thing?key=val service:did:web:com.example#type?key=val resource: resource:? resource:&amp; resource?</p><p>Examples which do not match the general syntax:</p><p>resource:positional?key=qu√©bec emoji:‚ò∫Ô∏è</p><p>Permission Sets Full-featured client apps require a large number of granular permissions to function: dozens or even hundreds of individual permissions. This presents a user experience and security challenge, as long lists of permissions are unlikely to be reviewed carefully, and a developer experience issue, as defining and maintaining these lists is toilsome.</p><p>To simplify permission management, Lexicon designers can define &quot;sets&quot; of permissions as part of the schemas they publish. These permission sets are themselves Lexicon schemas and are referred to by NSID, such as com.example.authBasicFeatures.</p><p>Authorization Servers resolve, authenticate, and process permission-sets dynamically. Sets include user-meaningful titles and summaries that are displayed to end users during the authorization request flow, with support for internationalization. These summaries improve consent comprehension and ultimately account security (the user interface should also make it possible to expand the specific granular permissions being granted). Permission sets are published publicly and can be used by any client developer. (Caching and fallback behaviors for dynamic resolution are discussed below.)</p><p>The below is an example permission set Lexicon. The full syntax is described in the Lexicon specification.</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.authBasicFeatures&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;permission-set&quot;, &quot;title&quot;: &quot;Basic App Functionality&quot;, &quot;title:lang&quot;: { &quot;ja&quot;: &quot;Âü∫Êú¨ÁöÑ„Å™„Ç¢„Éó„É™Ê©üËÉΩ&quot; }, &quot;detail&quot;: &quot;Creation of posts and interactions&quot;, &quot;detail:lang&quot;: { &quot;ja&quot;: &quot;ÊäïÁ®ø„Å®‰∫§ÊµÅ„ÅÆ‰ΩúÊàê&quot; }, &quot;permissions&quot;: [ { &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;repo&quot;, &quot;collection&quot;: [&quot;app.example.post&quot;] }, { &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;repo&quot;, &quot;collection&quot;: [&quot;app.example.like&quot;], &quot;action&quot;: [&quot;delete&quot;] }, { &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;rpc&quot;, &quot;inheritAud&quot;: true, &quot;lxm&quot;: [ &quot;app.example.getFeed&quot; &quot;app.example.getProfile&quot;, &quot;app.example.getPreferences&quot;, &quot;app.example.putPreferences&quot;, &quot;app.example.getAuthorFeed&quot;, ... ] }, { &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;rpc&quot;, &quot;aud&quot;: &quot;*&quot;, &quot;lxm&quot;: [&quot;app.example.getFeedSkeleton&quot;] } ] } } }</p><p>This entire set of permissions could be requested with an auth scope string like:</p><p>include:com.example.authBasicFeatures?aud=did:web:api.example.com%23svc_appview</p><p>Because some of the rpc permissions have the inheritAud flag set to true, the aud parameter on the include will be passed down to those specific rpc permissions. If the aud had not been part of the include, the default value (no audience) would have been used instead.</p><p>Permission sets are Lexicon schemas and are published and fetched using the Lexicon resolution system, which includes cryptographic authentication. Permission sets can be updated over time as new schemas are added to a namespace (eg, new record types or API endpoints). Authorization Servers are expected to maintain a cache of resolved sets, but to re-resolve them periodically. The permissions associated with an Access Token should remain fixed, but when a client refreshes their tokens (obtaining a new access token), the computed permissions for the session may be updated to reflect changes to sets requested by the client.</p><p>This adds an intentional degree of temporal dynamism to OAuth sessions involving permission sets. Lexicon designers can define new resources (eg, record types) and update published sets to include permissions to those resources. Client software can then be updated to take advantage of those new lexicons, without requiring users to re-authenticate their sessions. OAuth session are strictly limited to the auth scopes in the initial grant; it is the indirection of permission sets which enables this flexibility.</p><p>Authorization Servers and Resource Servers must ignore any individual permission declarations within a permission set that describe an unknown resource, or include unexpected parameter names or values. The reason for this behavior is that the permission system is expected to evolve over time, and new client permission requests should not be rejected in whole. At the same time, new parameters (fields) might attentuate permissions further, and it would be unsafe to grant partially-understood permissions.</p><p>Namespace Authority Permission sets are limited to expressing permissions that reference resources under the same NSID namespace as the set itself.</p><p>Authority is based on the relative structure of NSIDs, without &quot;siblings&quot; or special namespaces. Broadly, this ensures that sets can not request permissions across namespaces. Specifically:</p><p>Permission sets can address resources in the same NSID &quot;group&quot;; or &quot;children&quot; (sub-domains), recursively deep can not address &quot;sibling groups&quot; or &quot;parents&quot; in the NSID hierarchy For example, the set app.example.feed.authOnlyPost could include permissions to app.example.feed.post records and making app.example.feed.getPostThread API endpoint requests to remote services. But it could not grant permissions to app.example.actor.profile. A permission set app.example.authFull, which is a level up in the hierarchy, could include permissions to all these resources, or even further down the hierarchy.</p><p>Resolution and Caching Permission set Lexicons need to be resolved by Authorization Servers (eg, PDS instances). The existing Lexicon publication and resolution system describes how schemas are published and verified.</p><p>To reduce network traffic and increase resiliency to outages, Authorization Servers are expected to cache permission set resolution. Caches may be shared across all accounts and sessions on an Authorization Server.</p><p>Permission set schemas should be cached with long &quot;expiration&quot; times but shorter &quot;stale&quot; times. Stale Lexicons should get updated (aka, attempt resolution refresh), but if resolution fails, the previously existing stale values can be used. The recommended &quot;stale&quot; lifetime is 24 hours, and this is intended as a firm upper bound on cache lifetime. The firm lower bound on cache lifetime is that of access token lifetimes, meaning 15-30 minutes. The recommended &quot;expiration&quot; lifetime for referencing a permission set for a new auth session is 90 days, but this is not a firm bound. Existing auth sessions should not be impacted by the &quot;expiration&quot; of permission sets from any cache.</p><p>At the start of a session, if a permission set can not be resolved (and is not already in a local cache), the auth request will fail.</p><p>Usage and Implementation Guidelines The currently defined resources and parameters do not make use of all of the syntax flexibility. Implementations might decide to focus on currently used syntax instead of the general syntax.</p><p>Authorization Servers may chose to use a &quot;Lexicon Aggregator&quot; service to offload lexicon resolution of permission sets. Such services would monitor a full-network firehose to detect updated permission sets. They could contain security logic to protect against NSID domain hijacking or adversarial changes to permission set scope.</p><p>Possible Future Changes The set of resources is expected to expand over time as new functionality is added to the protocol.</p><p>Additional attributes are expected to be added to the account and identity resources.</p><p>An earlier proposal described a mechanism for purging permission set resolution caches. This would allow synchronized release of updated lexicon resources and updated client software, without concern that permissions would not be available to the client software due to cached resolution. This mechanism has not yet been implemented and is not included in the current specification.</p>',91)])])}const h=t(a,[["render",n]]);export{m as __pageData,h as default};
