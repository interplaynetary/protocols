import{_ as t,o,c as s,ag as i}from"./chunks/framework.BSbZkL3e.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"at-proto/guides/permission-sets.md","filePath":"at-proto/guides/permission-sets.md"}'),a={name:"at-proto/guides/permission-sets.md"};function r(n,e,p,u,d,l){return o(),s("div",null,[...e[0]||(e[0]=[i('<p>Permission Requests For app developers This guide describes how to request permissions for your AT Proto application. OAuth is used to authorize third-party applications to access users&#39; social graphs, and is a prerequisite for the concepts described here.</p><p>Control over AT Proto resources is described and granted using permissions. A group of a permissions related to a specific Lexicon namespace (record types and API endpoints) can be bundled together as a &quot;permission set&quot;. Both are used in the context of OAuth to grant client software access to account resources on a PDS: For example, the ability to write records of specific types to the user&#39;s public repository, or make authenticated API requests to remote services. Developers declare the permissions their app requires to function, and end users are shown the permissions when granting access to the app.</p><p>In general, it is best to use existing permission sets for cleaner UI, but you can also request individual permissions and define your own permission sets as needed. Refer to the for users section for how these requests appear in the OAuth flow.</p><p>Requesting permissions When your app initiates an OAuth flow with an ATProto identity provider, it can request specific permission sets by including them in the scope parameter of the authorization request. This should be supplied as a space-separated list in the oauth-client-metadata.json file when registering your OAuth client:</p><p>{ scope: &quot;atproto rpc:app.bsky.feed.searchPosts?aud=_ blob:_/*&quot;, ... }</p><p>Copy Copied! OAuth in AT uses Pushed Authorization Requests (PAR). The client metadata file will be fetched dynamically during the session lifecycle, and the scope parameter in oauth-client-metadata.json needs to match the actual authorization HTTP request made by your app:</p><p><a href="https://your-authorization-server.com/authorize" target="_blank" rel="noreferrer">https://your-authorization-server.com/authorize</a>? client_id=1234567890&amp; redirect_uri=<a href="https://your-app/callback&amp;" target="_blank" rel="noreferrer">https://your-app/callback&amp;</a> scope=atproto rpc:app.bsky.feed.searchPosts?aud=_ blob:_/* response_type=code&amp; audience=<a href="https://myapi" target="_blank" rel="noreferrer">https://myapi</a>&amp; state=1234567890</p><p>Copy Copied! You should try to only request enough permissions to cover the features your app needs. Transition scopes appear to grant permissions to create, update, or delete any of a user&#39;s AT records, including posts from other applications. In general, these broad permission requests should be avoided. This helps build trust with your users, and minimizes friction during the authorization process.</p><p>From a user experience perspective, it&#39;s best to keep the number of requested permission sets low. Each additional permission set adds more information to the authorization dialog, which can lead to decision fatigue. It is possible to allow users to grant only a subset of requested permissions, but this can lead to edge cases.</p><p>Permission types Permissions relate to user owned resources on PDS instances are are represented by five types:</p><p>repo: Public Repository (records and collections) rpc: Service Authentication (API calls to external services) blob: uploaded media files identity: DID and handle account: hosting status, email address Wildcards (<em>) are allowed in scope string syntax, and grants access to all records â€” the most common example being blob:</em>/<em>, for working with images and video. Partial wildcards are not supported â€” for example, app.bsky.</em> is not a valid scope string. If you wanted to request multiple permissions from a particular namespace or Lexicon, you would need to list them out individually, or use a permission set. This is intentional, to avoid overbroad permission requests.</p><p>Permission sets are themselves Lexicon schemas and are namespaced like other Lexicons. Unlike other Lexicons, permission sets are prefixed with include: in the scope string, and are dynamic; they can be updated.</p><p>Rolling out changes When you update your app to use new permission sets, it&#39;s important to coordinate the software release with the permission-set updates. If you add new permission sets that require user approval, users will need to re-authorize your app to grant these new permissions.</p><p>Your release and deployment process for the client metadata document may be separate from your app&#39;s code deployment process. Make sure to plan accordingly â€” an updated oauth-client-metadata.json that requests new permissions must be live before a version of your app that requires those permissions.</p><p>For Lexicon designers Lexicons are authored in JSON â€” you can find examples in the Lexicon Guide. Atmosphere HTTP API methods each scope and implement a particular set of Lexicons, so Lexicons must include valid query parameters, request bodies, and response bodies as appropriate. Each Lexicon, in turn, becomes a permission scope â€” in other words, app.bsky.feed.post is an AT record format, a web endpoint, and a granular permission all at once.</p><p>Lexicon schemas are published publicly as records in ATProto Lexicon repositories. Refer to Lexicon Publication and Resolution for technical details.</p><p>Permission Set design Full-featured client apps require a large number of granular permissions to function: dozens or even hundreds of individual permissions. To simplify permission management, Lexicon designers can define &quot;sets&quot; of permissions as part of the schemas they publish. These permission sets are themselves Lexicon schemas and are referred to by namespace ID, such as com.example.authBasicFeatures.</p><p>For example, your application could request a permission set like include:com.example.authBasicFeatures?aud=did:web:api.example.com%23svc_appview. This would resolve to a Lexicon that defines a set of permissions required for the app to function:</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.authBasicFeatures&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;permission-set&quot;, &quot;title&quot;: &quot;Basic App Functionality&quot;, &quot;detail&quot;: &quot;Creation of posts and interactions&quot;, &quot;permissions&quot;: [ { &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;repo&quot;, &quot;collection&quot;: [&quot;app.example.post&quot;] }, { &quot;type&quot;: &quot;permission&quot;, &quot;resource&quot;: &quot;rpc&quot;, &quot;inheritAud&quot;: true, &quot;lxm&quot;: [ &quot;app.example.getFeed&quot; &quot;app.example.getProfile&quot;, ... ] }, ] } } }</p><p>Copy Copied! Note the auth prefix in the app.example.feed.authOnlyPost and com.example.authBasicFeatures examples. This is a naming convention to indicate that the Lexicon is designed for use as a permission set.</p><p>Permission sets are limited to expressing permissions that reference resources under the same NSID namespace as the set itself. For example, the set app.example.feed.authOnlyPost could include permissions to app.example.feed.post records and making app.example.feed.getPostThread API endpoint requests to remote services. But it could not grant permissions to app.example.actor.profile. A permission set app.example.authFull, which is a level up in the hierarchy, could include permissions to all these resources.</p><p>The title and details fields are descriptive, and will be displayed as part of the OAuth flow; see the for users section for an example. Internationalization of these descriptive fields is supported â€” refer to the permission sets spec.</p><p>The use of inheritAud in the rpc permission allows you to control inheritance behavior.</p><p>The blob:<em>/</em> permission for image/video handling cannot be included in permission sets and must always be requested separately.</p><p>Linting and validating You can use goat to create and publish Lexicons. Before publishing, goat can also be used to lint and validate your Lexicon. For example, pulling and linting app.bsky.feed.post:</p><p>$ goat lex pull app.bsky.feed.post ðŸŸ¢ app.bsky.feed.post</p><p>$ goat lex lint lexicons/app/bsky/feed/post.json ðŸŸ¡ lexicons/app/bsky/feed/post.json [unlimited-string]: no max length [unlimited-string]: no max length error: linting issues detected</p><p>Copy Copied! Nobody&#39;s perfect ðŸ˜Š</p><p>You can create a new Lexicon record with goat lex new record:</p><p>$ goat lex new record dev.project.thing</p><p>Copy Copied! Develop your Lexicon following the style guide, and then eventually publish it with goat lex publish:</p><p>$ goat lex publish ðŸŸ¢ dev.project.thing</p><p>Copy Copied! After publishing a new Lexicon, you can verify that it is live with goat lex resolve:</p><p>$ goat lex resolve app.bsky.feed.post</p><p>{ &quot;$type&quot;: &quot;com.atproto.lexicon.schema&quot;, &quot;defs&quot;: { &quot;entity&quot;: { &quot;description&quot;: &quot;Deprecated: use facets instead.&quot;, &quot;properties&quot;: { &quot;index&quot;: { &quot;ref&quot;: &quot;#textSlice&quot;, &quot;type&quot;: &quot;ref&quot; }, &quot;type&quot;: { &quot;description&quot;: &quot;Expected values are &#39;mention&#39; and &#39;link&#39;.&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;value&quot;: { &quot;type&quot;: &quot;string&quot; ...</p><p>Copy Copied! Revising Permission Sets Permission sets can be revised, but removing them or making destructive changes can break existing applications. In general, permission sets should be closely tied to the applications they are designed for, but not necessarily 1:1. Remember that AT Proto applications can utilize multiple different Lexicons.</p><p>OAuth flow examples Apps that are using ATProto identity providers solely for authentication only need to request the atproto permission. This provides the same OAuth flow that you might expect from other identity providers; no features of the Atmosphere social graph are used, and no additional permissions are required:</p><p>This is a fully usable Atmosphere integration, and many applications will use this as a starting point. Note that it produces a straightforward, readable &quot;Authorize&quot; flow. The URL of the requesting app is clearly visible, and the permissions dialog states that the app &quot;wants to uniquely identify you,&quot; but nothing else.</p><p>Next, consider a more complex integration, that requests additional permissions. By default, these will be presented in a summarized view:</p><p>In this image, note that there are two different Lexicon groupings: Bluesky permissions, and Skyblur permissions. Each Lexicon defines its own permission sets, as well as its own grouping and presentation of those permissions.</p><p>You can click through on the ? icons to see the details of each permission set:</p><p>From the expanded ATProto and Bluesky permissions, you might recognize atproto (for OAuth login), blob:<em>/</em> (for image and video handling), and several other app.bsky.* permissions for profile and social graph interactions.</p><p>The Skyblur Lexicon permissions are defined and summarized differently:</p><p>This is all at the discretion of app developers and Lexicon designers. We provide a model for using different Lexicons side by side, and for each Lexicon to define its own permission sets and presentation.</p>',44)])])}const m=t(a,[["render",r]]);export{h as __pageData,m as default};
