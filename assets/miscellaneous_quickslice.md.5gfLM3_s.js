import{_ as t,o as i,c as o,ag as a}from"./chunks/framework.BSbZkL3e.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"miscellaneous/quickslice.md","filePath":"miscellaneous/quickslice.md"}'),s={name:"miscellaneous/quickslice.md"};function r(n,e,u,c,l,p){return i(),o("div",null,[...e[0]||(e[0]=[a('<p>quickslice Auto-indexing service and GraphQL API for AT Protocol Records</p><p>quickslice</p><p>bigmoves/quickslice:latest</p><p>Just deployed</p><p>/data</p><p>Deploy and Host quickslice on Railway quickslice is a GraphQL API server for AT Protocol records. It automatically generates GraphQL schemas from Lexicon definitions, providing real-time data ingestion via Jetstream, historical backfill support, and Relay-compliant cursor-based pagination.</p><p>About Hosting quickslice quickslice runs as a containerized Gleam/Erlang application with SQLite for storage. Hosting requires a Docker-capable platform with persistent volume support for the database. The server ingests data from the AT Protocol firehose in real-time and serves it via GraphQL. Configuration is handled through environment variables for OAuth and via the settings page once the application is deployed. The application exposes a health check endpoint at /health and a GraphiQL interface at /graphiql for query exploration.</p><p>Common Use Cases Application backends: Build apps on AT Protocol data with filtering, sorting, and real-time subscriptions Data exploration: Use GraphiQL to explore AT Protocol records interactively with automatic schema generation from Lexicons Dependencies for quickslice Hosting Persistent Volume: SQLite database requires persistent storage Environment Secrets: OAUTH_SIGNING_KEY P-256 private key in multibase format (z-prefixed base58btc) for signing OAuth JWTs. Generate via the goat cli <a href="https://formulae.brew.sh/formula/goat" target="_blank" rel="noreferrer">https://formulae.brew.sh/formula/goat</a>. The command is: goat key generate -t p256 Deployment Dependencies <a href="https://atproto.com" target="_blank" rel="noreferrer">https://atproto.com</a><a href="https://formulae.brew.sh/formula/goat" target="_blank" rel="noreferrer">https://formulae.brew.sh/formula/goat</a><a href="https://quickslice.slices.network" target="_blank" rel="noreferrer">https://quickslice.slices.network</a> Implementation Details Environment variables to configure: OAUTH_SIGNING_KEY=</p><p>Volume mount: /data (1GB minimum)</p><p>Health check path: /health</p><p>Why Deploy quickslice on Railway? Railway is a singular platform to deploy your infrastructure stack. Railway will host your infrastructure so you don&#39;t have to deal with configuration, while allowing you to vertically and horizontally scale it.</p><p>By deploying quickslice on Railway, you are one step closer to supporting a complete full-stack application with minimal burden. Host your servers, databases, AI agents, and more on Railway.</p><hr><p>quickslice v0.20.0 Search docs... Stars 51 CHANGELOG Getting Started Introduction Tutorial Guides Queries Joins Mutations Moderation Notifications Viewer State Authentication Deployment Patterns Troubleshooting Reference Aggregations Subscriptions Blobs Variables MCP Quickslice Warning This project is in early development. APIs may change without notice.</p><p>Quickslice is a quick way to spin up an AppView for AT Protocol applications. Import your Lexicon schemas and you get a GraphQL API with OAuth authentication, real-time sync from the network, and joins across record types without setting up a database or writing any backend code.</p><p>#The Problem Building an AppView from scratch means writing a lot of infrastructure code:</p><p>Jetstream connection and event handling Record ingestion and validation Database schema design and normalization XRPC API endpoints for querying and writing data OAuth session management and PDS writes Efficient batching when resolving related records This adds up before you write any application logic.</p><p>#What Quickslice Does Quickslice handles all of that automatically:</p><p>Connects to Jetstream and tracks the record types defined in your Lexicons Indexes relevant records into a database (SQLite or Postgres) Generates GraphQL queries, mutations, and subscriptions from your Lexicon definitions Handles OAuth and writes records back to the user&#39;s PDS Enables joins by DID, URI, or strong reference, so you can query a status and its author&#39;s profile in one request #When to Use It You want to skip the AppView boilerplate You want to prototype Lexicon data structures quickly You want OAuth handled for you You want to ship your AppView already #Next Steps Build Statusphere with Quickslice: A hands-on tutorial showing what Quickslice handles for you</p><p>Previous CHANGELOG Next Tutorial On this page The Problem What Quickslice Does When to Use It Next Steps</p><hr><p>quickslice v0.20.0 Search docs... Stars 51 CHANGELOG Getting Started Introduction Tutorial Guides Queries Joins Mutations Moderation Notifications Viewer State Authentication Deployment Patterns Troubleshooting Reference Aggregations Subscriptions Blobs Variables MCP Tutorial: Build Statusphere with Quickslice Let&#39;s build Statusphere, an app where users share their current status as an emoji. This is the same app from the AT Protocol docs, but using Quickslice as the AppView.</p><p>Along the way, we&#39;ll show what you&#39;d write manually versus what Quickslice handles automatically.</p><p>Try it live: A working example is running at StackBlitz, connected to a slice at xyzstatusphere.slices.network with the xyz.statusphere.status lexicon.</p><p>NOTE: For the StackBliz example, OAuth will only work if you open the preview in a new tab and login from there ü´†.</p><p>#What We&#39;re Building Statusphere lets users:</p><p>Log in with their AT Protocol identity Set their status as an emoji See a feed of everyone&#39;s statuses with profile information By the end of this tutorial, you&#39;ll understand how Quickslice eliminates the boilerplate of building an AppView.</p><p>#Step 1: Project Setup and Importing Lexicons Every AT Protocol app starts with Lexicons. Here&#39;s the Lexicon for a status record:</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;xyz.statusphere.status&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;record&quot;, &quot;key&quot;: &quot;tid&quot;, &quot;record&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;status&quot;, &quot;createdAt&quot;], &quot;properties&quot;: { &quot;status&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;minLength&quot;: 1, &quot;maxGraphemes&quot;: 1, &quot;maxLength&quot;: 32 }, &quot;createdAt&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;datetime&quot; } } } } } } Importing this Lexicon into Quickslice triggers three automatic steps:</p><p>Jetstream registration: Quickslice tracks xyz.statusphere.status records from the network Database schema: Quickslice creates a normalized table with proper columns and indexes GraphQL types: Quickslice generates query, mutation, and subscription types Without Quickslice With Quickslice Write Jetstream connection code Import your Lexicon Filter events for your collection xyz.statusphere.status Validate incoming records Design database schema Quickslice handles the rest. Write ingestion logic #Step 2: Querying Status Records Query indexed records with GraphQL. Quickslice generates a query for each Lexicon type using Relay-style connections:</p><p>query GetStatuses { xyzStatusphereStatus( first: 20 sortBy: [{ field: createdAt, direction: DESC }] ) { edges { node { uri did status createdAt } } } } The edges and nodes pattern comes from Relay, a GraphQL pagination specification. Each edge contains a node (the record) and a cursor for pagination.</p><p>You can filter with where clauses:</p><p>query RecentStatuses { xyzStatusphereStatus( first: 10 where: { status: { eq: &quot;üëç&quot; } } ) { edges { node { did status } } } } Without Quickslice With Quickslice Design query API Query is auto-generated: Write database queries Handle pagination logic xyzStatusphereStatus { edges { node { status } } } Build filtering and sorting #Step 3: Joining Profile Data Here Quickslice shines. Every status record has a did field identifying its author. In Bluesky, profile information lives in app.bsky.actor.profile records. Join directly from a status to its author&#39;s profile:</p><p>query StatusesWithProfiles { xyzStatusphereStatus(first: 20) { edges { node { status createdAt appBskyActorProfileByDid { displayName avatar { url } } } } } } The appBskyActorProfileByDid field is a DID join. It follows the did on the status record to find the profile authored by that identity.</p><p>Quickslice:</p><p>Collects DIDs from the status records Batches them into a single database query (DataLoader pattern) Joins profile data efficiently Without Quickslice With Quickslice Collect DIDs from status records Add join to your query: Batch resolve DIDs to profiles Handle N+1 query problem appBskyActorProfileByDid { displayName } Write batching logic Join data in API response #Other Join Types Quickslice also supports:</p><p>Forward joins: Follow a URI or strong ref to another record Reverse joins: Find all records that reference a given record See the Joins Guide for complete documentation.</p><p>#Step 4: Writing a Status (Mutations) To set a user&#39;s status, call a mutation:</p><p>mutation CreateStatus($status: String!, $createdAt: DateTime!) { createXyzStatusphereStatus( input: { status: $status, createdAt: $createdAt } ) { uri status createdAt } } Quickslice:</p><p>Writes to the user&#39;s PDS: Creates the record in their personal data repository Indexes optimistically: The record appears in queries immediately, before Jetstream confirmation Handles OAuth: Uses the authenticated session to sign the write Without Quickslice With Quickslice Get OAuth session/agent Call the mutation: Construct record with $type Call putRecord XRPC on the PDS createXyzStatusphereStatus(input: { status: &quot;üëç&quot; }) Optimistically update local DB Handle errors #Step 5: Authentication Quickslice bridges AT Protocol OAuth. Your frontend initiates login; Quickslice manages the authorization flow:</p><p>User enters their handle (e.g., alice.bsky.social) Your app redirects to Quickslice&#39;s OAuth endpoint Quickslice redirects to the user&#39;s PDS for authorization User approves the app PDS redirects back to Quickslice with an auth code Quickslice exchanges the code for tokens and establishes a session For authenticated queries and mutations, include auth headers. The exact headers depend on your OAuth flow (DPoP or Bearer token). See the Authentication Guide for details.</p><p>#Step 6: Deploying to Railway Deploy quickly with Railway:</p><p>Click the deploy button in the Quickstart Guide Generate an OAuth signing key with goat key generate -t p256 Paste the key into the OAUTH_SIGNING_KEY environment variable Generate a domain and redeploy Create your admin account by logging in Upload your Lexicons See Deployment Guide for detailed instructions.</p><p>#What Quickslice Handled Quickslice handled:</p><p>Jetstream connection: firehose connection, event filtering, reconnection Record validation: schema checking against Lexicons Database schema: tables, migrations, indexes Query API: filtering, sorting, pagination endpoints Batching: efficient related-record resolution Optimistic updates: indexing before Jetstream confirmation OAuth flow: token exchange, session management, DPoP proofs Focus on your application logic; Quickslice handles infrastructure.</p><p>#Next Steps Queries Guide: Filtering, sorting, and pagination Joins Guide: Forward, reverse, and DID joins Mutations Guide: Creating, updating, and deleting records Authentication Guide: Setting up OAuth Deployment Guide: Production configuration Previous Introduction Next Queries On this page What We&#39;re Building Step 1: Project Setup and Importing Lexicons Step 2: Querying Status Records Step 3: Joining Profile Data Other Join Types Step 4: Writing a Status (Mutations) Step 5: Authentication Step 6: Deploying to Railway What Quickslice Handled Next Steps</p><hr>',47)])])}const g=t(s,[["render",r]]);export{h as __pageData,g as default};
