import{_ as e,o as u,c as i,ag as o,j as a}from"./chunks/framework.BSbZkL3e.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"at-proto/guides/lexicon.md","filePath":"at-proto/guides/lexicon.md"}'),q={name:"at-proto/guides/lexicon.md"};function s(n,t,r,p,c,d){return u(),i("div",null,[...t[0]||(t[0]=[o("<p>Intro to Lexicon Lexicon is a schema system used to define RPC methods and record types. Every Lexicon schema is written in JSON, in a format similar to JSON-Schema for defining constraints.</p><p>The schemas are identified using NSIDs which are a reverse-DNS format. Here are some example API endpoints:</p><p>com.atproto.repo.getRecord com.atproto.identity.resolveHandle app.bsky.feed.getPostThread app.bsky.notification.listNotifications</p><p>Copy Copied! And here are some example record types:</p><p>app.bsky.feed.post app.bsky.feed.like app.bsky.actor.profile app.bsky.graph.follow</p><p>Copy Copied! The schema types, definition language, and validation constraints are described in the Lexicon specification, and representations in JSON and CBOR are described in the Data Model specification.</p><p>Why is Lexicon needed? Interoperability. An open network like atproto needs a way to agree on behaviors and semantics. Lexicon solves this while making it relatively simple for developers to introduce new schemas.</p><p>Lexicon is not RDF. While RDF is effective at describing data, it is not ideal for enforcing schemas. Lexicon is easier to use because it doesn&#39;t need the generality that RDF provides. In fact, Lexicon&#39;s schemas enable code-generation with types and validation, which makes life much easier!</p><p>HTTP API methods The AT Protocol&#39;s API system, XRPC, is essentially a thin wrapper around HTTPS. For example, a call to:</p><p>com.example.getProfile()</p><p>Copy Copied! is actually just an HTTP request:</p><p>GET /xrpc/com.example.getProfile</p><p>Copy Copied! The schemas establish valid query parameters, request bodies, and response bodies.</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.getProfile&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;query&quot;, &quot;parameters&quot;: { &quot;type&quot;: &quot;params&quot;, &quot;required&quot;: [&quot;user&quot;], &quot;properties&quot;: { &quot;user&quot;: { &quot;type&quot;: &quot;string&quot; } }, }, &quot;output&quot;: { &quot;encoding&quot;: &quot;application/json&quot;, &quot;schema&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;did&quot;, &quot;name&quot;], &quot;properties&quot;: { &quot;did&quot;: {&quot;type&quot;: &quot;string&quot;}, &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;}, &quot;displayName&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;maxLength&quot;: 64}, &quot;description&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;maxLength&quot;: 256} } } } } } }</p><p>Copy Copied! With code-generation, these schemas become very easy to use:</p>",15),a("p",{"name:":"","bob.com,":"","did:":"","did:plc:1234,":"","displayName:":"","css-module":".', ."},"await client.com.example.getProfile({user: 'bob.com'}) // =>",-1),o("<p>Copy Copied! Record types Schemas define the possible values of a record. Every record has a &quot;type&quot; which maps to a schema and also establishes the URL of a record.</p><p>For instance, this &quot;follow&quot; record:</p><p>{ &quot;$type&quot;: &quot;com.example.follow&quot;, &quot;subject&quot;: &quot;at://did:plc:12345&quot;, &quot;createdAt&quot;: &quot;2022-10-09T17:51:55.043Z&quot; }</p><p>Copy Copied! ...would have a URL like:</p><p>at://bob.com/com.example.follow/12345</p><p>Copy Copied! ...and a schema like:</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.follow&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;record&quot;, &quot;description&quot;: &quot;A social follow&quot;, &quot;record&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;subject&quot;, &quot;createdAt&quot;], &quot;properties&quot;: { &quot;subject&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;createdAt&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;datetime&quot;} } } } } }</p><p>Copy Copied! Tokens Tokens declare global identifiers which can be used in data.</p><p>Let&#39;s say a record schema wanted to specify three possible states for a traffic light: &#39;red&#39;, &#39;yellow&#39;, and &#39;green&#39;.</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.trafficLight&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;record&quot;, &quot;record&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;state&quot;], &quot;properties&quot;: { &quot;state&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;] }, } } } } }</p><p>Copy Copied! This is perfectly acceptable, but it&#39;s not extensible. You could never add new states, like &quot;flashing yellow&quot; or &quot;purple&quot; (who knows, it could happen).</p><p>To add flexibility, you could remove the enum constraint and just document the possible values:</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.trafficLight&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;record&quot;, &quot;record&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;state&quot;], &quot;properties&quot;: { &quot;state&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Suggested values: red, yellow, green&quot; } } } } } }</p><p>Copy Copied! This isn&#39;t bad, but it lacks specificity. People inventing new values for state are likely to collide with each other, and there won&#39;t be clear documentation on each state.</p><p>Instead, you can define Lexicon tokens for the values you use:</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.green&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;token&quot;, &quot;description&quot;: &quot;Traffic light state representing &#39;Go!&#39;.&quot;, } } } { &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.yellow&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;token&quot;, &quot;description&quot;: &quot;Traffic light state representing &#39;Stop Soon!&#39;.&quot;, } } } { &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.red&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;token&quot;, &quot;description&quot;: &quot;Traffic light state representing &#39;Stop!&#39;.&quot;, } } }</p><p>Copy Copied! This gives us unambiguous values to use in our trafficLight state. The final schema will still use flexible validation, but other teams will have more clarity on where the values originate from and how to add their own:</p><p>{ &quot;lexicon&quot;: 1, &quot;id&quot;: &quot;com.example.trafficLight&quot;, &quot;defs&quot;: { &quot;main&quot;: { &quot;type&quot;: &quot;record&quot;, &quot;record&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;required&quot;: [&quot;state&quot;], &quot;properties&quot;: { &quot;state&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;knownValues&quot;: [ &quot;com.example.green&quot;, &quot;com.example.yellow&quot;, &quot;com.example.red&quot; ] } } } } } }</p><p>Copy Copied! Versioning Once a schema is published, it can never change its constraints. Loosening a constraint (adding possible values) will cause old software to fail validation for new data, and tightening a constraint (removing possible values) will cause new software to fail validation for old data. As a consequence, schemas may only add optional constraints to previously unconstrained fields.</p><p>If a schema must change a previously-published constraint, it should be published as a new schema under a new NSID.</p><p>Schema distribution Schemas are designed to be machine-readable and network-accessible. While it is not currently required that a schema is available on the network, it is strongly advised to publish schemas so that a single canonical &amp; authoritative representation is available to consumers of the method.</p>",21)])])}const h=e(q,[["render",s]]);export{m as __pageData,h as default};
