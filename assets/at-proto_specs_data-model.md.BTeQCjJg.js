import{_ as t,o as i,c as o,ag as a}from"./chunks/framework.BSbZkL3e.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"at-proto/specs/data-model.md","filePath":"at-proto/specs/data-model.md"}'),n={name:"at-proto/specs/data-model.md"};function s(r,e,l,d,c,p){return i(),o("div",null,[...e[0]||(e[0]=[a("<p>Data Model Records and messages in atproto are stored, transmitted, encoded, and authenticated in a consistent way. The core &quot;data model&quot; supports both binary (CBOR) and textual (JSON) representations.</p><p>When data needs to be authenticated (signed), referenced (linked by content hash), or stored efficiently, it is encoded in Concise Binary Object Representation (CBOR). CBOR is an IETF standard roughly based on JSON. The specific normalized subset of CBOR used in the atproto data model is called DRISL (which is successor to DAG-CBOR). All DRISL-CBOR data is valid CBOR, and can be read with any CBOR library. Writing or strictly verifying CBOR with the correct normalization rules sometimes requires additional configuration or a special CBOR implementation.</p><p>The schema definition language for atproto is Lexicon. Other lower-level data structures, like repository internals, are not specified with Lexicons, but use the same data model and encodings.</p><p>Distinct pieces of data are called nodes, and when encoded in binary (DRISL-CBOR) result in a block. A node may have internal nested structure (maps or lists). Nodes may reference each other by string URLs or URIs, just like with regular JSON on the web. They can also reference each other strongly by hash, referred a link. A set of linked nodes can form higher-level data structures like Merkle Trees or Directed Acyclical Graphs (DAG). Links can also refer to arbitrary binary data (blobs).</p><p>Unlike URLs, hash references (links) do not encode a specific network location where the content can be found. The location and access mechanism must be inferred by protocol-level context. Hash references do have the property of being &quot;self-certifying&quot;, meaning that returned data can be verified against the link hash. This makes it possible to redistribute content and trust copies even if coming from an untrusted party.</p><p>Links are encoded as Content Identifiers (CIDs), which have both binary and string representations. CIDs include a metadata code which indicates whether it links to a node (DRISL-CBOR) or arbitrary binary data. Some additional constraints on the use of CIDs in atproto are described below.</p><p>In atproto, object nodes often include a string field $type that specifies their Lexicon schema. Data is mostly self-describing and can be processed in schema-agnostic ways (including decoding and re-encoding), but can not be fully validated without the schema on-hand or known ahead of time.</p><p>Relationship With DASL and IPLD The atproto data model aligns with DASL, a specification for hash-linked data structures. DASL libraries and tooling can be used when implementing atproto. DASL itself is a subset of Interplanetary Linked Data (IPLD).</p><p>IPLD specified a normalized JSON encoding called DAG-JSON, but atproto uses a different set of conventions when encoding JSON data. The atproto JSON encoding is not designed to be byte-determinisitic, and the CBOR representation is used when data needs to be cryptographically signed or hashed.</p><p>Data Types Lexicon Type DASL Type JSON CBOR Note</p><ul><li>null Null Special Value (major 7) boolean boolean Boolean Special Value (major 7) integer integer Number Integer (majors 0,1) signed, 64-bit string string String UTF-8 String (major 3) Unicode, UTF-8</li><li>float Number Special (major 7) not allowed in atproto bytes bytes $bytes Object Byte String (major 2) cid-link link $link Object CID (tag 42) CID array list Array Array (major 4) object map Object Map (major 5) keys are always strings blob - $type: blob Object $type: blob Map blob is for references to files, such as images. It includes basic metadata like MIME Type and size (in bytes).</li></ul><p>As a best practice to ensure Javascript compatibility with default types, integer should be limited to 53 bits of precision. Note that JSON numbers can have an arbitrary number of digits, but integer is limited to 64 bits even ignoring Javascript.</p><p>Lexicons can include additional validation constraints on individual fields. For example, integers can have maximum and minimum values. Data can not be validated against these additional constraints without access to the relevant Lexicon schema, but there is a concept of validating free-form JSON or CBOR against the atproto data model in an abstract sense. For example, a JSON object with a nested $bytes object with a boolean instead of a base64-encoded string might be valid JSON, but can never be valid under the atproto data model.</p><p>Lexicon string fields can have additional format type information associated with them for validation, but as with other validation constraints this information is not available without the Lexicon itself.</p><p>Data field names starting with $ are reserved for use by the data model or protocol itself, in both JSON and CBOR representations. For example, the $bytes key name (used in CBOR and JSON), the $link key (used for JSON CID Links), or $type (used to indicate record type). Implementations should ignore unknown $ fields (to allow protocol evolution). Applications, extensions, and integrations should not use or unilaterally define new $ fields, to prevent conflicts as the protocol evolves.</p><p>Nullable and False-y In the atproto data model there is a semantic difference between explicitly setting an map field to null and not including the field at all. Both JSON and CBOR have the same distinction.</p><p>Null or missing fields are also distinct from &quot;false-y&quot; value like false (for booleans), 0 (for integers), empty lists, or empty objects.</p><p>Why No Floats? CBOR and JSON both natively support floating point numbers, so why does atproto go out of the way to disallow them?</p><p>The IPLD specification describes some of the complexities and sharp edges when working with floats in a content-addressable world. In short, de-serializing in to machine-native format, then later re-encoding, is not always consistent. This is definitely true for special values and corner-cases, but can even be true with &quot;normal&quot; float values on less-common architectures.</p><p>It may be possible to come up with rules to ensure reliable round-trip encoding of floats in the future, but for now we disallow floats.</p><p>If you have a use-case where integers can not be substituted for floats, we recommend encoding the floats as strings or even bytes. This provides a safe default round-trip representation.</p><p>blob Type References to &quot;blobs&quot; (arbitrary files) have a consistent format in atproto, and can be detected and processed without access to any specific Lexicon. That is, it is possible to parse nodes and extract any blob references without knowing the schema.</p><p>Blob nodes are maps with following fields:</p><p>$type (string, required): fixed value blob. Note that this is not a valid NSID. ref (link, required): CID reference to blob, with multicodec type raw. In JSON, encoded as a $link object as usual mimeType (string, required, not empty): content type of blob. application/octet-stream if not known size (integer, required, positive, non-zero): length of blob in bytes There is also a deprecated legacy blob format, with some records in the wild still containing blob references in this format:</p><p>cid (string, required): a CID in string format, not link format mimeType (string, required, not empty): same as mimeType above Note that the legacy format has no $type and can only be parsed for known Lexicons. Implementations should not throw errors when encountering the old format, but should never write them, and it is acceptable to only partially support them.</p><p>JSON Representation atproto uses its own conventions for JSON, instead of using DAG-JSON directly. The main motivation was to have more idiomatic and human-readable representations for link and bytes in HTTP APIs. The DAG-JSON specification itself mentions that it is primarily oriented toward debugging and development environments, and we found that the use of / as a field key was confusing to developers.</p><p>Normalizations like key sorting are also not required or enforced when using JSON in atproto: only DRISL-CBOR is used as a byte-reproducible representation.</p><p>The encoding for most of the core and compound types is straight forward, with only link and bytes needing special treatment.</p><p>link The JSON encoding for link is an object with the single key $link and the string-encoded CID as a value.</p><p>For example, a node with a single field &quot;exampleLink&quot; with type link would encode in JSON like:</p><p>{ &quot;exampleLink&quot;: { &quot;$link&quot;: &quot;bafyreidfayvfuwqa7qlnopdjiqrxzs6blmoeu4rujcjtnci5beludirz2a&quot; } }</p><p>For comparison, this is very similar to the DAG-JSON encoding, but substitutes $link as the key name instead of / (single-character, forward slash).</p><p>bytes The JSON encoding for bytes is an object with the single key $bytes and string value with the base64-encoded bytes. The base64 scheme is the one specified in RFC-4648, section 4, frequently referred to as simple &quot;base64&quot;. This scheme is not URL-safe, and = padding is optional.</p><p>For example, a node with a single field &quot;exampleBytes&quot; with type bytes would be represented in JSON like:</p><p>{ &quot;exampleBytes&quot;: { &quot;$bytes&quot;: &quot;nFERjvLLiw9qm45JrqH9QTzyC2Lu1Xb4ne6+sBrCzI0&quot; } }</p><p>For comparison, the DAG-JSON encoding has two nested objects, with outer key / (single-character, forward slash), inner key bytes, and the same base64 encoding.</p><p>Link and CID Formats The original IPFS CID specification is very flexible. It supports a wide variety of hash types, a field indicating the &quot;type&quot; of content being linked to, and various string encoding options. These features are valuable to allow evolution over time, but to maximize interoperability among implementations, only a specific &quot;blessed&quot; set of CID types are allowed. These align with the DASL CID specification.</p><p>The blessed formats for CIDs in atproto are:</p><p>CID version: 1 (0x01) Codec: DRISL (0x71; also known as dag-cbor) for links to DRISL-CBOR data objects, and raw (0x55) for links to blobs Hash type: sha-256 (0x12) with size of 256 bits (0x20 bytes) Encoding: binary serialization within DRISL-CBOR cid-link fields, and base32 (with b prefix) for string encoding elsewhere The use of SHA-256 is a stable requirement in some contexts, such as the repository MST nodes. In other contexts, like referencing media blobs, there will likely be a set of &quot;blessed&quot; hash types which evolve over time. A balance needs to be struck between protocol flexibility on the one hand (to adopt improved hashes and remove weak ones), and ensuring broad and consistent interoperability throughout an ecosystem of protocol implementations.</p><p>There are several ways to include a CID hash reference in an atproto object:</p><p>link field type (Lexicon type cid-link). In DRISL-CBOR, CIDs are encoded by prefixing their binary representation with 0x00. The CBOR tag used to represent CIDs is 42. In JSON, encodes as $link objects (see above). string field type, with Lexicon string format cid. In DRISL-CBOR and JSON, encodes as a simple string string field type, with Lexicon string format uri, with URI scheme ipld:// Usage and Implementation Guidelines When working with the deprecated/legacy &quot;blob&quot; format, it is recommend to store in the same internal representation as regular &quot;blob&quot; references, but to set the size to zero or a negative value. This field should be checked when re-serializing to ensure proper round-trip behavior and avoid ever encoding a zero or negative size value in the normal object format.</p><p>Best practices for validating and limiting the size and structure of generic atproto data are described in a Data Validation guide, which is not formally part of this specification.</p><p>Security and Privacy Considerations There are a number of resource-consumption attacks possible when parsing untrusted CBOR content. It is recommended to use a library that automatically protects against huge allocations, deep nesting, invalid references, etc. This is particularly important for libraries implemented in languages without strong memory safety, such as C and C++. Note that high-level languages frequently wrap parsers written in lower-level languages.</p><p>Possible Future Changes Floats may be supported in one form or another.</p><p>The legacy &quot;blob&quot; format may be entirely removed, if all known records and repositories can be rewritten.</p><p>Additional hash types are likely to be included in the set of &quot;blessed&quot; CID configurations.</p>",46)])])}const b=t(n,[["render",s]]);export{u as __pageData,b as default};
