/*
 * THIS FILE WAS GENERATED BY "@atproto/lex". DO NOT EDIT.
 */

import { l } from '@atproto/lex'
import * as OpenassociationDefs from './defs.defs.js'

const $nsid = 'org.openassociation.recipeFlow'

export { $nsid }

/** The specification of a resource inflow to, or outflow from, a recipe process; and/or a clause, or reciprocal clause, of a recipe exchange. */
type Main = {
  $type: 'org.openassociation.recipeFlow'

  /**
   * Defines the kind of flow, such as consume, produce, work, transfer, etc.
   */
  action: l.AtUriString

  /**
   * Relates an input flow to its process in a recipe.
   */
  recipeInputOf?: l.AtUriString

  /**
   * Relates an output flow to its process in a recipe.
   */
  recipeOutputOf?: l.AtUriString

  /**
   * Relates a flow to its exchange agreement in a recipe.
   */
  recipeClauseOf?: l.AtUriString

  /**
   * Relates a reciprocal flow to its exchange agreement in a recipe.
   */
  recipeReciprocalClauseOf?: l.AtUriString

  /**
   * The amount and unit of the economic resource counted or inventoried.
   */
  resourceQuantity?: OpenassociationDefs.Measure

  /**
   * The amount and unit of the work or use or citation effort-based action. This is often expressed with a time unit, but also could be cycle counts or other measures of effort or usefulness.
   */
  effortQuantity?: OpenassociationDefs.Measure

  /**
   * Any useful textual information related to the item.
   */
  note?: string

  /**
   * References one or more uri's for a concept in a common taxonomy or other classification scheme for purposes of categorization or grouping; or can be one or more string classifications such as tags.
   */
  resourceClassifiedAs?: string[]

  /**
   * The lowest level resource specification or definition of an existing or potential economic resource, whether one will ever be instantiated or not.
   */
  resourceConformsTo?: l.AtUriString

  /**
   * The required stage of the desired input economic resource. References the ProcessSpecification of the last process the economic resource went through.
   */
  stage?: l.AtUriString

  /**
   * The required state of the desired input economic resource, after coming out of a test or review process.
   */
  state?: string
}

export type { Main }

/** The specification of a resource inflow to, or outflow from, a recipe process; and/or a clause, or reciprocal clause, of a recipe exchange. */
const main = l.record<'tid', Main>(
  'tid',
  $nsid,
  l.object({
    action: l.string({ format: 'at-uri' }),
    recipeInputOf: l.optional(l.string({ format: 'at-uri' })),
    recipeOutputOf: l.optional(l.string({ format: 'at-uri' })),
    recipeClauseOf: l.optional(l.string({ format: 'at-uri' })),
    recipeReciprocalClauseOf: l.optional(l.string({ format: 'at-uri' })),
    resourceQuantity: l.optional(
      l.ref<OpenassociationDefs.Measure>(
        (() => OpenassociationDefs.measure) as any,
      ),
    ),
    effortQuantity: l.optional(
      l.ref<OpenassociationDefs.Measure>(
        (() => OpenassociationDefs.measure) as any,
      ),
    ),
    note: l.optional(l.string({ maxGraphemes: 10000 })),
    resourceClassifiedAs: l.optional(l.array(l.string())),
    resourceConformsTo: l.optional(l.string({ format: 'at-uri' })),
    stage: l.optional(l.string({ format: 'at-uri' })),
    state: l.optional(l.string()),
  }),
)

export { main }

export const $isTypeOf = /*#__PURE__*/ main.isTypeOf.bind(main),
  $build = /*#__PURE__*/ main.build.bind(main),
  $type = /*#__PURE__*/ main.$type
export const $assert = /*#__PURE__*/ main.assert.bind(main),
  $check = /*#__PURE__*/ main.check.bind(main),
  $cast = /*#__PURE__*/ main.cast.bind(main),
  $ifMatches = /*#__PURE__*/ main.ifMatches.bind(main),
  $matches = /*#__PURE__*/ main.matches.bind(main),
  $parse = /*#__PURE__*/ main.parse.bind(main),
  $safeParse = /*#__PURE__*/ main.safeParse.bind(main),
  $validate = /*#__PURE__*/ main.validate.bind(main),
  $safeValidate = /*#__PURE__*/ main.safeValidate.bind(main)
